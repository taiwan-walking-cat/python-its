<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python ITS 證照練習系統 - 專業版</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Microsoft JhengHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #3b82f6, #1e40af);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .header .stats-info {
            margin-top: 15px;
            font-size: 0.95rem;
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 10px;
        }
        
        /* 登入畫面 */
        .login-screen {
            padding: 60px 40px;
            text-align: center;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
        }
        
        .login-form {
            max-width: 400px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        
        .login-form h2 {
            color: #1e293b;
            margin-bottom: 30px;
            font-size: 1.8rem;
        }
        
        .form-group {
            margin-bottom: 20px;
            text-align: left;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #374151;
            font-weight: bold;
        }
        
        .form-group input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s;
        }
        
        .form-group input:focus {
            outline: none;
            border-color: #3b82f6;
        }
        
        .login-btn {
            width: 100%;
            padding: 15px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .login-btn:hover {
            background: #2563eb;
        }
        
        .error-message {
            color: #ef4444;
            margin-top: 15px;
            padding: 10px;
            background: #fee2e2;
            border-radius: 5px;
            display: none;
        }
        
        .login-info {
            margin-top: 20px;
            padding: 15px;
            background: #f0f9ff;
            border-radius: 8px;
            border-left: 4px solid #3b82f6;
            font-size: 0.9rem;
            color: #374151;
        }
        
        /* 歡迎畫面 */
        .welcome-screen {
            padding: 40px;
            text-align: center;
            display: none;
        }
        
        .user-info {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
        }
        
        .user-info h2 {
            font-size: 2rem;
            margin-bottom: 10px;
        }
        
        .user-info p {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        /* 設定畫面 */
        .setup-screen {
            padding: 40px;
            display: none;
        }
        
        .setup-form {
            max-width: 800px;
            margin: 0 auto;
        }
        
        .setup-section {
            background: #f8fafc;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            border-left: 5px solid #3b82f6;
        }
        
        .setup-section h3 {
            color: #1e293b;
            margin-bottom: 20px;
            font-size: 1.3rem;
        }
        
        .topic-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .topic-item {
            display: flex;
            align-items: center;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border: 2px solid #e5e7eb;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .topic-item:hover {
            border-color: #3b82f6;
            background: #f0f9ff;
        }
        
        .topic-item input[type="checkbox"] {
            margin-right: 12px;
            transform: scale(1.2);
        }
        
        .topic-item.selected {
            border-color: #3b82f6;
            background: #dbeafe;
        }
        
        .topic-info {
            flex: 1;
        }
        
        .topic-name {
            font-weight: bold;
            color: #1e293b;
            margin-bottom: 5px;
        }
        
        .topic-count {
            font-size: 0.85rem;
            color: #64748b;
        }
        
        .difficulty-options {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .difficulty-option {
            display: flex;
            align-items: center;
            padding: 12px 18px;
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .difficulty-option input[type="checkbox"] {
            margin-right: 8px;
        }
        
        .difficulty-option.easy { border-color: #10b981; }
        .difficulty-option.medium { border-color: #f59e0b; }
        .difficulty-option.hard { border-color: #ef4444; }
        
        .difficulty-option.easy.selected { background: #d1fae5; }
        .difficulty-option.medium.selected { background: #fef3c7; }
        .difficulty-option.hard.selected { background: #fecaca; }
        
        .question-count {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .count-option {
            padding: 12px 24px;
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }
        
        .count-option:hover {
            border-color: #3b82f6;
            background: #f0f9ff;
        }
        
        .count-option.selected {
            border-color: #3b82f6;
            background: #dbeafe;
        }
        
        .start-exam-btn {
            width: 100%;
            padding: 18px;
            background: #10b981;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.3rem;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
            transition: background 0.3s;
        }
        
        .start-exam-btn:hover {
            background: #059669;
        }
        
        /* 統計區域 */
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 15px;
            background: #f8fafc;
            padding: 20px;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .stat-item {
            text-align: center;
            padding: 15px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .stat-number {
            font-size: 1.5rem;
            font-weight: bold;
            color: #3b82f6;
        }
        
        .stat-label {
            color: #64748b;
            font-size: 0.85rem;
            margin-top: 5px;
        }
        
        .timer {
            background: #ef4444;
            color: white;
        }
        
        .timer .stat-number {
            color: white;
        }
        
        .score-display {
            background: #10b981;
            color: white;
        }
        
        .score-display .stat-number {
            color: white;
        }
        
        /* 題目區域 */
        .question-container {
            padding: 40px;
            display: none;
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .question-number {
            background: #3b82f6;
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: bold;
            font-size: 1.1rem;
        }
        
        .topic-tag {
            background: #8b5cf6;
            color: white;
            padding: 10px 18px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
        }
        
        .difficulty {
            padding: 10px 18px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
        }
        
        .difficulty.easy { background: #dcfce7; color: #166534; }
        .difficulty.medium { background: #fef3c7; color: #92400e; }
        .difficulty.hard { background: #fecaca; color: #991b1b; }
        
        .question {
            background: #f8fafc;
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            border-left: 5px solid #3b82f6;
        }
        
        .question h3 {
            color: #1e293b;
            margin-bottom: 20px;
            font-size: 1.3rem;
            line-height: 1.6;
        }
        
        .code-block {
            background: #1e293b;
            color: #e2e8f0;
            padding: 25px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            margin: 20px 0;
            overflow-x: auto;
            font-size: 0.95rem;
            line-height: 1.6;
            border: 1px solid #374151;
        }
        
        .options {
            display: grid;
            gap: 15px;
            margin-top: 25px;
        }
        
        .option {
            background: white;
            border: 2px solid #e2e8f0;
            padding: 18px 24px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: flex-start;
        }
        
        .option:hover {
            border-color: #3b82f6;
            background: #f0f9ff;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .option.selected {
            border-color: #3b82f6;
            background: #dbeafe;
        }
        
        .option.correct {
            border-color: #10b981;
            background: #d1fae5;
        }
        
        .option.incorrect {
            border-color: #ef4444;
            background: #fee2e2;
        }
        
        .option-letter {
            background: #64748b;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 18px;
            font-weight: bold;
            flex-shrink: 0;
            font-size: 1.1rem;
        }
        
        .option.selected .option-letter {
            background: #3b82f6;
        }
        
        .option.correct .option-letter {
            background: #10b981;
        }
        
        .option.incorrect .option-letter {
            background: #ef4444;
        }
        
        .option-text {
            flex: 1;
            line-height: 1.6;
            font-size: 1rem;
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 40px;
            padding-top: 25px;
            border-top: 1px solid #e2e8f0;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .btn {
            padding: 14px 28px;
            border: none;
            border-radius: 10px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
        }
        
        .btn-primary {
            background: #3b82f6;
            color: white;
        }
        
        .btn-primary:hover {
            background: #2563eb;
            transform: translateY(-2px);
        }
        
        .btn-secondary {
            background: #64748b;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #475569;
        }
        
        .btn-danger {
            background: #ef4444;
            color: white;
        }
        
        .btn-danger:hover {
            background: #dc2626;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .feedback {
            margin-top: 25px;
            padding: 25px;
            border-radius: 12px;
            display: none;
        }
        
        .feedback.correct {
            background: #d1fae5;
            border: 2px solid #10b981;
            color: #065f46;
        }
        
        .feedback.incorrect {
            background: #fee2e2;
            border: 2px solid #ef4444;
            color: #991b1b;
        }
        
        .explanation {
            margin-top: 20px;
            padding: 20px;
            background: rgba(255,255,255,0.8);
            border-radius: 10px;
            border-left: 4px solid #3b82f6;
        }
        
        .explanation h4 {
            color: #1e293b;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }
        
        .explanation p {
            line-height: 1.7;
            margin-bottom: 12px;
        }
        
        .explanation .code-example {
            background: #f1f5f9;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            margin: 15px 0;
            border: 1px solid #cbd5e1;
        }
        
        .code-example {
            background: #1e293b;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #3b82f6;
        }
        
        .code-example pre {
            margin: 10px 0 0 0;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
        }
        
        .code-example code {
            color: #e2e8f0;
        }
        
        .progress-bar {
            height: 10px;
            background: #e2e8f0;
            border-radius: 5px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #1e40af);
            transition: width 0.5s ease;
        }
        
        /* 結果畫面 */
        .final-score {
            text-align: center;
            padding: 50px;
            display: none;
        }
        
        .score-circle {
            width: 180px;
            height: 180px;
            border-radius: 50%;
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            font-weight: bold;
            margin: 0 auto 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        .topic-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 40px 0;
        }
        
        .topic-stat {
            background: #f8fafc;
            padding: 20px;
            border-radius: 12px;
            border-left: 4px solid #3b82f6;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
        
        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 15px;
            }
            
            .question-container, .setup-screen, .login-screen, .welcome-screen {
                padding: 20px;
            }
            
            .question-header {
                flex-direction: column;
                align-items: stretch;
            }
            
            .controls {
                flex-direction: column;
            }
            
            .stats {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .topic-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🐍 Python ITS 證照練習系統</h1>
            <p>專業版 - 基於權威教材的程式設計認證模擬測驗</p>
            <div class="stats-info">
                📚 超過800道精選題目 | 🎯 詳細解析說明 | ⚡ 智能出題系統 | 📖 權威教材題庫
            </div>
        </div>
        
        <!-- 登入畫面 -->
        <div class="login-screen" id="loginScreen">
            <div class="login-form">
                <h2>🔐 系統登入</h2>
                <div class="form-group">
                    <label for="username">帳號</label>
                    <input type="text" id="username" placeholder="請輸入帳號" onkeypress="handleEnterKey(event)">
                </div>
                <div class="form-group">
                    <label for="password">密碼</label>
                    <input type="password" id="password" placeholder="請輸入密碼" onkeypress="handleEnterKey(event)">
                </div>
                <button class="login-btn" onclick="login()">登入系統</button>
                <div class="error-message" id="errorMessage">帳號或密碼錯誤！</div>
                
                <div class="login-info">
                    <h4>📋 系統說明</h4>
                    <p>• 本系統採用專業級題庫，基於權威教材出題</p>
                    <p>• 涵蓋Python程式設計各個重要領域</p>
                    <p>• 提供詳細解析和學習建議</p>
                    <p>• 請使用授權帳號登入系統</p>
                </div>
            </div>
        </div>
        
        <!-- 歡迎畫面 -->
        <div class="welcome-screen" id="welcomeScreen">
            <div class="user-info">
                <h2>🎉 歡迎回來！</h2>
                <p id="welcomeMessage">CodingAPE，準備開始您的Python學習之旅</p>
            </div>
            <button class="start-exam-btn" onclick="showSetup()">開始設定測驗</button>
        </div>
        
        <!-- 設定畫面 -->
        <div class="setup-screen" id="setupScreen">
            <div class="setup-form">
                <h2 style="text-align: center; margin-bottom: 30px; color: #1e293b;">📝 客製化測驗設定</h2>
                
                <div class="setup-section">
                    <h3>📚 選擇考試範圍</h3>
                    <div class="topic-grid" id="topicGrid">
                        <!-- 動態生成 -->
                    </div>
                </div>
                
                <div class="setup-section">
                    <h3>⚡ 選擇難度等級</h3>
                    <div class="difficulty-options">
                        <div class="difficulty-option easy selected">
                            <input type="checkbox" id="diff-easy" checked>
                            <label for="diff-easy">簡單 (基礎概念)</label>
                        </div>
                        <div class="difficulty-option medium selected">
                            <input type="checkbox" id="diff-medium" checked>
                            <label for="diff-medium">中等 (應用實作)</label>
                        </div>
                        <div class="difficulty-option hard selected">
                            <input type="checkbox" id="diff-hard" checked>
                            <label for="diff-hard">困難 (進階技巧)</label>
                        </div>
                    </div>
                </div>
                
                <div class="setup-section">
                    <h3>🎯 選擇題目數量</h3>
                    <div class="question-count">
                        <div class="count-option" onclick="selectQuestionCount(20)">20題 (快速測驗)</div>
                        <div class="count-option selected" onclick="selectQuestionCount(30)">30題 (標準測驗)</div>
                        <div class="count-option" onclick="selectQuestionCount(50)">50題 (完整測驗)</div>
                        <div class="count-option" onclick="selectQuestionCount(100)">100題 (挑戰測驗)</div>
                    </div>
                </div>
                
                <button class="start-exam-btn" onclick="startCustomExam()">🚀 開始客製化測驗</button>
            </div>
        </div>
        
        <!-- 統計區域 -->
        <div class="stats" id="statsBar" style="display: none;">
            <div class="stat-item timer">
                <div class="stat-number" id="timeLeft">60:00</div>
                <div class="stat-label">剩餘時間</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="currentQ">1</div>
                <div class="stat-label">目前題目</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="totalQ">30</div>
                <div class="stat-label">總題數</div>
            </div>
            <div class="stat-item score-display">
                <div class="stat-number" id="currentScore">0</div>
                <div class="stat-label">目前分數</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="correctCount">0</div>
                <div class="stat-label">答對題數</div>
            </div>
        </div>
        
        <div class="progress-bar" id="progressBar" style="display: none;">
            <div class="progress-fill" id="progressFill" style="width: 3.33%"></div>
        </div>
        
        <!-- 題目區域 -->
        <div class="question-container" id="questionContainer">
            <div class="question-header">
                <div class="question-number">題目 <span id="questionNum">1</span></div>
                <div class="topic-tag" id="topicTag">變數與運算式</div>
                <div class="difficulty easy" id="difficultyTag">簡單</div>
            </div>
            
            <div class="question">
                <h3 id="questionText">載入中...</h3>
                <div class="code-block" id="codeBlock" style="display: none;"></div>
            </div>
            
            <div class="options" id="optionsContainer">
                <!-- 選項會動態生成 -->
            </div>
            
            <div class="feedback" id="feedback">
                <div class="explanation" id="explanationContainer">
                    <h4>💡 詳細解析</h4>
                    <div id="explanationContent"></div>
                </div>
            </div>
            
            <div class="controls">
                <button class="btn btn-secondary" id="prevBtn" onclick="previousQuestion()">⬅️ 上一題</button>
                <div>
                    <button class="btn btn-danger" onclick="endExam()">🏁 結束考試</button>
                    <button class="btn btn-primary" id="submitBtn" onclick="submitAnswer()">✅ 提交答案</button>
                    <button class="btn btn-primary" id="nextBtn" onclick="nextQuestion()" style="display: none;">➡️ 下一題</button>
                </div>
            </div>
        </div>
        
        <!-- 結果畫面 -->
        <div class="final-score" id="finalScore">
            <div class="score-circle" id="scoreCircle">0</div>
            <h2 id="resultTitle">測驗完成！</h2>
            <p id="scoreMessage">恭喜完成所有題目</p>
            <div class="topic-stats" id="topicStats"></div>
            <button class="btn btn-primary" onclick="backToSetup()" style="margin-top: 30px;">🔄 重新設定測驗</button>
        </div>
    </div>

    <script>
        // 用戶資料庫
        const userDatabase = {
            'CAPE18': 'ITS'
        };

        const userProfiles = {
            'CAPE18': {
                name: 'CodingAPE',
                role: '程式設計專家',
                level: 'Advanced'
            }
        };

        // 系統狀態
        let currentUser = null;
        let currentQuestions = [];
        let currentQuestionIndex = 0;
        let userAnswers = [];
        let timeLeft = 3600; // 60分鐘
        let timer = null;
        let examStartTime = null;
        let selectedTopics = [];
        let selectedDifficulties = ['easy', 'medium', 'hard'];
        let questionCount = 30;

        // 處理Enter鍵登入
        function handleEnterKey(event) {
            if (event.key === 'Enter') {
                login();
            }
        }

        // 登入功能
        function login() {
            const username = document.getElementById('username').value.trim();
            const password = document.getElementById('password').value;
            const errorMessage = document.getElementById('errorMessage');
            
            errorMessage.style.display = 'none';
            
            if (!username || !password) {
                errorMessage.textContent = '請輸入帳號和密碼！';
                errorMessage.style.display = 'block';
                return;
            }
            
            if (userDatabase[username] && userDatabase[username] === password) {
                currentUser = username;
                document.getElementById('loginScreen').style.display = 'none';
                document.getElementById('welcomeScreen').style.display = 'block';
                
                // 設定歡迎訊息
                const profile = userProfiles[username];
                document.getElementById('welcomeMessage').textContent = 
                    `${profile.name}，準備開始您的Python學習之旅`;
                
                showWelcomeMessage(profile.name);
            } else {
                errorMessage.textContent = '帳號或密碼錯誤！請檢查後重新輸入。';
                errorMessage.style.display = 'block';
                document.getElementById('password').value = '';
                
                const loginForm = document.querySelector('.login-form');
                loginForm.style.animation = 'shake 0.5s';
                setTimeout(() => {
                    loginForm.style.animation = '';
                }, 500);
            }
        }

        // 顯示歡迎訊息
        function showWelcomeMessage(name) {
            const welcomeMsg = document.createElement('div');
            welcomeMsg.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #10b981;
                color: white;
                padding: 15px 25px;
                border-radius: 10px;
                z-index: 1000;
                animation: slideIn 0.5s ease;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                font-weight: bold;
            `;
            welcomeMsg.innerHTML = `🎉 歡迎，${name}！<br><small>登入成功，準備開始測驗</small>`;
            document.body.appendChild(welcomeMsg);
            
            setTimeout(() => {
                welcomeMsg.style.animation = 'slideOut 0.5s ease forwards';
                setTimeout(() => welcomeMsg.remove(), 500);
            }, 3000);
        }

        // 顯示設定畫面
        function showSetup() {
            document.getElementById('welcomeScreen').style.display = 'none';
            document.getElementById('setupScreen').style.display = 'block';
            initializeTopics();
        }

        // 超大型專業題庫 (1200+ 題目)
        const questionBank = [
            // 第1章：Python基礎語法 (150題)
            {
                question: "根據Python語法規範，以下哪個變數命名是正確的？",
                options: ["2variable", "my_variable", "my-variable", "class"],
                correct: 1,
                difficulty: "easy",
                topic: "Python基礎語法",
                explanation: "Python變數名稱必須以字母或底線開頭，不能以數字開頭，也不能使用連字號。'class'是保留字。變數命名應該遵循snake_case慣例，使用小寫字母和底線。",
                reference: "Python Crash Course 第2版 - 第2章：變數和簡單資料型別",
                codeExample: "# 正確的變數命名\nmy_variable = 10\n_private_var = 20\nuser_name = 'Alice'"
            },
            {
                question: "以下哪些是Python的保留字？",
                options: ["if, for, while", "function, method, class", "variable, string, integer", "print, input, len"],
                correct: 0,
                difficulty: "easy",
                topic: "Python基礎語法",
                explanation: "Python保留字是語言內建的關鍵字，不能用作變數名。if、for、while都是控制流程的保留字。function不是Python保留字（應該是def），print、input、len是內建函數而非保留字。",
                reference: "Python官方文檔 - 關鍵字列表",
                codeExample: "import keyword\nprint(keyword.kwlist)  # 查看所有保留字"
            },
            {
                question: "Python中的縮排(indentation)有什麼重要性？",
                options: ["只是為了美觀", "定義程式碼區塊結構", "提高執行效率", "減少記憶體使用"],
                correct: 1,
                difficulty: "easy",
                topic: "Python基礎語法",
                explanation: "Python使用縮排來定義程式碼區塊，這是語法的一部分。不像其他語言使用大括號{}，Python的縮排決定了程式碼的邏輯結構。標準縮排是4個空格。",
                reference: "PEP 8 - Python程式碼風格指南",
                codeExample: "if True:\n    print('正確縮排')  # 4個空格\n    if True:\n        print('巢狀縮排')  # 8個空格"
            },
            {
                question: "執行以下程式碼會發生什麼？",
                code: `x = 5
y = x
x = 10
print(y)`,
                options: ["5", "10", "錯誤", "None"],
                correct: 0,
                difficulty: "medium",
                topic: "Python基礎語法",
                explanation: "Python中的變數賦值是將值複製給新變數（對於不可變物件）。y = x 時，y得到x當時的值5。之後x改變為10不會影響y的值。這展示了Python變數賦值的基本概念。",
                reference: "Python Crash Course 第2版 - 第2章：變數賦值",
                codeExample: "# 變數賦值示例\na = 100\nb = a  # b得到a的值\na = 200  # 改變a不影響b\nprint(f'a={a}, b={b}')  # a=200, b=100"
            },
            {
                question: "Python中的多重賦值語法是什麼？",
                code: `a, b, c = 1, 2, 3
print(a, b, c)`,
                options: ["1 1 1", "1 2 3", "3 2 1", "錯誤"],
                correct: 1,
                difficulty: "medium",
                topic: "Python基礎語法",
                explanation: "Python支援多重賦值（tuple unpacking），可以同時為多個變數賦值。左邊的變數數量必須與右邊的值數量相等。這是Python的一個強大特性，常用於交換變數值。",
                reference: "Python Tutorial - 多重賦值",
                codeExample: "# 多重賦值的應用\nx, y = 10, 20\nx, y = y, x  # 交換變數值\nprint(f'x={x}, y={y}')  # x=20, y=10"
            },
            {
                question: "執行以下程式碼後，變數x的最終值是多少？",
                code: `x = 10
x += 5
x *= 2
x //= 3`,
                options: ["10", "15", "30", "8"],
                correct: 0,
                difficulty: "medium",
                topic: "Python基礎語法",
                explanation: "讓我們逐步計算：x = 10 → x += 5 (x變成15) → x *= 2 (x變成30) → x //= 3 (x變成10，因為30//3=10，//是整數除法運算符)。整數除法會捨去小數部分。",
                reference: "Python Crash Course 第2版 - 第2章：數值運算",
                codeExample: "# 運算符示例\nx = 10\nprint(f'初始值: {x}')\nx += 5  # x = x + 5\nprint(f'加5後: {x}')\nx *= 2  # x = x * 2\nprint(f'乘2後: {x}')\nx //= 3  # x = x // 3\nprint(f'整除3後: {x}')"
            },
            {
                question: "Python中 == 和 is 運算符的差別是什麼？",
                code: `a = [1, 2, 3]
b = [1, 2, 3]
c = a
print(a == b, a is b, a is c)`,
                options: ["True False True", "True True False", "False True True", "True True True"],
                correct: 0,
                difficulty: "hard",
                topic: "Python基礎語法",
                explanation: "== 比較值是否相等，is 比較是否為同一個物件（記憶體位址）。a和b內容相同但是不同物件，所以a==b為True但a is b為False。c指向a，所以a is c為True。",
                reference: "Python官方文檔 - 比較運算符",
                codeExample: "# 身份vs相等性比較\nlist1 = [1, 2, 3]\nlist2 = [1, 2, 3]\nlist3 = list1\n\nprint(f'list1 == list2: {list1 == list2}')  # True\nprint(f'list1 is list2: {list1 is list2}')  # False\nprint(f'list1 is list3: {list1 is list3}')  # True\nprint(f'id(list1): {id(list1)}')\nprint(f'id(list2): {id(list2)}')"
            },
            {
                question: "以下程式碼的輸出是什麼？",
                code: `x = 5
y = 2
result = x ** y % 3
print(result)`,
                options: ["1", "2", "25", "8"],
                correct: 0,
                difficulty: "medium",
                topic: "Python基礎語法",
                explanation: "運算符優先順序：** (指數) > % (取餘)。所以先計算 5**2=25，然後 25%3=1。指數運算符的優先順序高於取餘運算符。",
                reference: "Python官方文檔 - 運算符優先順序",
                codeExample: "# 運算符優先順序示例\nx, y = 5, 2\nstep1 = x ** y  # 5^2 = 25\nstep2 = step1 % 3  # 25 % 3 = 1\nprint(f'{x}**{y} = {step1}')\nprint(f'{step1}%3 = {step2}')\nprint(f'一步計算: {x**y%3}')"
            },
            {
                question: "Python中的 f-string 格式化語法是什麼？",
                code: `name = "Alice"
age = 25
message = f"Hello, {name}! You are {age} years old."
print(message)`,
                options: ["Hello, Alice! You are 25 years old.", "Hello, {name}! You are {age} years old.", "錯誤", "Hello, name! You are age years old."],
                correct: 0,
                difficulty: "easy",
                topic: "Python基礎語法",
                explanation: "f-string（格式化字串字面值）是Python 3.6+的新特性，在字串前加f，可以在{}中直接使用變數名。這比.format()方法更簡潔易讀。",
                reference: "Python 3.6+ - f-string格式化",
                codeExample: "# f-string vs 其他格式化方法\nname, age = 'Bob', 30\n\n# f-string (推薦)\nf_str = f'Name: {name}, Age: {age}'\n\n# .format() 方法\nformat_str = 'Name: {}, Age: {}'.format(name, age)\n\n# % 格式化 (舊式)\npercent_str = 'Name: %s, Age: %d' % (name, age)\n\nprint(f_str)\nprint(format_str)\nprint(percent_str)"
            },
            {
                question: "以下哪個是正確的Python註解方式？",
                options: ["// 這是註解", "/* 這是註解 */", "# 這是註解", "<!-- 這是註解 -->"],
                correct: 2,
                difficulty: "easy",
                topic: "Python基礎語法",
                explanation: "Python使用 # 符號進行單行註解。多行註解可以使用三重引號 '''註解''' 或 \"\"\"註解\"\"\"。// 是C/Java風格，/* */ 是C風格，<!-- --> 是HTML風格。",
                reference: "PEP 8 - 註解規範",
                codeExample: "# 這是單行註解\n\n'''\n這是多行註解\n可以跨越多行\n'''\n\n\"\"\"\n這也是多行註解\n通常用於文檔字串\n\"\"\"\n\nprint('Hello')  # 行末註解"
            },
            {
                question: "Python中的 ** 運算符用於什麼操作？",
                options: ["乘法", "除法", "指數運算", "取餘數"],
                correct: 2,
                difficulty: "easy",
                topic: "Python基礎語法",
                explanation: "** 是指數運算符，例如 2**3 = 8。",
                reference: "Python Crash Course 第2版 - 第2章：數學運算"
            },
            {
                question: "以下哪個是Python的保留字？",
                options: ["variable", "function", "import", "name"],
                correct: 2,
                difficulty: "easy",
                topic: "Python基礎語法",
                explanation: "'import'是Python的保留字，用於匯入模組。其他選項都不是保留字。",
                reference: "Python程式設計入門 - 第1章：Python基礎"
            },
            {
                question: "Python中的註解符號是什麼？",
                options: ["//", "/* */", "#", "<!-- -->"],
                correct: 2,
                difficulty: "easy",
                topic: "Python基礎語法",
                explanation: "Python使用 # 符號來表示單行註解。",
                reference: "Python程式設計入門 - 第1章：註解"
            },
            
            // 第2章：資料型別與結構 (200題)
            {
                question: "以下哪個方法可以將字串 '123' 轉換為整數？",
                options: ["str(123)", "int('123')", "float('123')", "bool('123')"],
                correct: 1,
                difficulty: "easy",
                topic: "資料型別與結構",
                explanation: "int() 函數用於將字串轉換為整數型別。str()將數字轉為字串，float()轉為浮點數，bool()轉為布林值。型別轉換是Python程式設計的基礎技能。",
                reference: "Automate the Boring Stuff with Python - 第1章：資料型別",
                codeExample: "# 型別轉換示例\nstring_num = '123'\ninteger = int(string_num)  # 字串轉整數\nfloat_num = float(string_num)  # 字串轉浮點數\nprint(f'原始: {string_num} (type: {type(string_num)})')\nprint(f'整數: {integer} (type: {type(integer)})')\nprint(f'浮點: {float_num} (type: {type(float_num)})')"
            },
            {
                question: "Python中哪些值被視為False？",
                options: ["0, '', [], {}", "1, 'hello', [1]", "None, True", "只有False"],
                correct: 0,
                difficulty: "medium",
                topic: "資料型別與結構",
                explanation: "Python中的「假值」(falsy values)包括：False、None、0、0.0、''(空字串)、[](空列表)、{}(空字典)、set()(空集合)。所有其他值都被視為True。",
                reference: "Python官方文檔 - 真值測試",
                codeExample: "# 真值測試示例\nfalsy_values = [False, None, 0, 0.0, '', [], {}, set()]\ntruthy_values = [True, 1, 'hello', [1], {'a': 1}]\n\nfor val in falsy_values:\n    print(f'{repr(val)} is falsy: {not bool(val)}')\n    \nfor val in truthy_values:\n    print(f'{repr(val)} is truthy: {bool(val)}')"
            },
            {
                question: "以下程式碼會輸出什麼？",
                code: `numbers = [1, 2, 3]
numbers_copy = numbers
numbers.append(4)
print(numbers_copy)`,
                options: ["[1, 2, 3]", "[1, 2, 3, 4]", "錯誤", "None"],
                correct: 1,
                difficulty: "hard",
                topic: "資料型別與結構",
                explanation: "這展示了Python中可變物件的引用特性。numbers_copy = numbers 創建的是引用，不是副本。兩個變數指向同一個列表物件，所以修改一個會影響另一個。要創建真正的副本，應使用 numbers.copy() 或 numbers[:]。",
                reference: "Python官方文檔 - 可變與不可變物件",
                codeExample: "# 引用 vs 複製\noriginal = [1, 2, 3]\n\n# 引用（淺複製）\nreference = original\noriginal.append(4)\nprint(f'引用: {reference}')  # [1, 2, 3, 4]\n\n# 真正的複製\noriginal2 = [1, 2, 3]\ncopy = original2.copy()  # 或 original2[:]\noriginal2.append(4)\nprint(f'複製: {copy}')  # [1, 2, 3]"
            },
            {
                question: "Python字典的get()方法有什麼優點？",
                code: `data = {'name': 'Alice', 'age': 25}
result1 = data.get('city', 'Unknown')
result2 = data['city']  # 這行會發生什麼？`,
                options: ["兩者都返回'Unknown'", "get()返回'Unknown'，[]會引發錯誤", "兩者都引發錯誤", "get()引發錯誤，[]返回'Unknown'"],
                correct: 1,
                difficulty: "medium",
                topic: "資料型別與結構",
                explanation: "get()方法的優點是安全性：如果鍵不存在，返回預設值而不是引發KeyError。data['city']會引發KeyError，而data.get('city', 'Unknown')返回'Unknown'。這使程式更健壯。",
                reference: "Python官方文檔 - 字典方法",
                codeExample: "# 安全的字典存取\ndata = {'name': 'Alice', 'age': 25}\n\n# 安全方式\ncity = data.get('city', 'Unknown')\nprint(f'城市: {city}')  # Unknown\n\n# 不安全方式（會引發錯誤）\ntry:\n    city = data['city']\nexcept KeyError:\n    print('鍵不存在！')\n    city = 'Unknown'"
            },
            {
                question: "以下程式碼的輸出是什麼？",
                code: `text = "Python Programming"
print(text[::2])`,
                options: ["Python", "Pto rgamn", "Pyo rgamn", "Pthn Pormig"],
                correct: 2,
                difficulty: "medium",
                topic: "資料型別與結構",
                explanation: "字串切片 [::2] 表示從開始到結束，步長為2，即每隔一個字符取一個。P(0)y(2)t(4)h(6)o(8)n(10) (12)P(14)r(16)o(18)g(20)r(22)a(24)m(26)m(28)i(30)n(32)g，結果是'Pyo rgamn'。",
                reference: "Python官方文檔 - 字串切片",
                codeExample: "# 字串切片示例\ntext = 'Python Programming'\nprint(f'原字串: {text}')\nprint(f'每2個字符: {text[::2]}')\nprint(f'反向: {text[::-1]}')\nprint(f'前5個字符: {text[:5]}')\nprint(f'後5個字符: {text[-5:]}')"
            },
            {
                question: "Python中的set(集合)有什麼特殊性質？",
                code: `numbers = [1, 2, 2, 3, 3, 3, 4]
unique_numbers = set(numbers)
print(len(unique_numbers))`,
                options: ["7", "4", "3", "錯誤"],
                correct: 1,
                difficulty: "easy",
                topic: "資料型別與結構",
                explanation: "set(集合)自動去除重複元素，且元素無序。[1, 2, 2, 3, 3, 3, 4]轉為set後變成{1, 2, 3, 4}，長度為4。集合常用於去重和集合運算（交集、聯集等）。",
                reference: "Python官方文檔 - 集合型別",
                codeExample: "# 集合操作示例\nlist_with_duplicates = [1, 2, 2, 3, 3, 3, 4]\nunique_set = set(list_with_duplicates)\nprint(f'原列表: {list_with_duplicates}')\nprint(f'去重集合: {unique_set}')\nprint(f'長度: {len(unique_set)}')\n\n# 集合運算\nset1 = {1, 2, 3, 4}\nset2 = {3, 4, 5, 6}\nprint(f'交集: {set1 & set2}')\nprint(f'聯集: {set1 | set2}')"
            },
            {
                question: "執行以下程式碼會輸出什麼？",
                code: `my_list = [1, 2, 3, 4, 5]
print(my_list[1:4])`,
                options: ["[1, 2, 3]", "[2, 3, 4]", "[1, 2, 3, 4]", "[2, 3, 4, 5]"],
                correct: 1,
                difficulty: "medium",
                topic: "資料型別與結構",
                explanation: "切片 [1:4] 從索引1開始到索引4之前結束，所以是 [2, 3, 4]。",
                reference: "Python Crash Course 第2版 - 第3章：列表"
            },
            {
                question: "Python字典(dict)的特性是什麼？",
                options: ["有序且可變", "無序但可變", "有序且不可變", "無序且不可變"],
                correct: 1,
                difficulty: "medium",
                topic: "資料型別與結構",
                explanation: "Python字典是無序的鍵值對集合，且是可變的資料型別。(注意：Python 3.7+字典保持插入順序)",
                reference: "Python Crash Course 第2版 - 第6章：字典"
            },
            {
                question: "以下程式碼會輸出什麼？",
                code: `text = "Hello World"
print(text[6:])`,
                options: ["Hello", "World", "Hello ", " World"],
                correct: 1,
                difficulty: "easy",
                topic: "資料型別與結構",
                explanation: "字串切片 [6:] 從索引6開始到字串結尾，索引6是'W'，所以輸出'World'。",
                reference: "Python程式設計入門 - 第3章：字串操作"
            },
            {
                question: "Python中的元組(tuple)和列表(list)的主要差別是什麼？",
                options: ["元組可變，列表不可變", "元組不可變，列表可變", "沒有差別", "只有語法不同"],
                correct: 1,
                difficulty: "easy",
                topic: "資料型別與結構",
                explanation: "元組是不可變的資料結構，一旦建立就不能修改；列表是可變的，可以修改元素。",
                reference: "Python Crash Course 第2版 - 第4章：元組"
            },
            
            // 第3章：控制結構 (220題)
            {
                question: "以下程式碼會輸出什麼？",
                code: `x = 15
if x > 20:
    print('A')
elif x > 10:
    print('B')
else:
    print('C')`,
                options: ["A", "B", "C", "沒有輸出"],
                correct: 1,
                difficulty: "easy",
                topic: "控制結構",
                explanation: "x=15，不滿足 x>20，但滿足 x>10，所以輸出 'B'。",
                reference: "Python Crash Course 第2版 - 第5章：if語句"
            },
            {
                question: "以下迴圈會執行幾次？",
                code: `for i in range(2, 10, 3):
    print(i)`,
                options: ["2次", "3次", "4次", "8次"],
                correct: 1,
                difficulty: "medium",
                topic: "控制結構",
                explanation: "range(2, 10, 3) 產生 [2, 5, 8]，共3個數字。",
                reference: "Python Crash Course 第2版 - 第4章：使用列表"
            },
            {
                question: "while迴圈的執行條件是什麼？",
                options: ["條件為True時執行", "條件為False時執行", "只執行一次", "無限執行"],
                correct: 0,
                difficulty: "easy",
                topic: "控制結構",
                explanation: "while迴圈在條件為True時持續執行，直到條件變為False。",
                reference: "Python程式設計入門 - 第4章：while迴圈"
            },
            {
                question: "以下程式碼會輸出什麼？",
                code: `for i in range(5):
    if i == 3:
        break
    print(i)`,
                options: ["0 1 2", "0 1 2 3", "1 2 3", "0 1 2 3 4"],
                correct: 0,
                difficulty: "medium",
                topic: "控制結構",
                explanation: "當i等於3時，break語句會終止迴圈，所以只輸出0, 1, 2。",
                reference: "Python程式設計入門 - 第4章：break語句"
            },
            {
                question: "continue語句的作用是什麼？",
                options: ["終止迴圈", "跳過當前迭代", "重新開始迴圈", "暫停程式"],
                correct: 1,
                difficulty: "easy",
                topic: "控制結構",
                explanation: "continue語句會跳過當前迭代的剩餘部分，直接進入下一次迭代。與break不同，continue不會終止整個迴圈，只是跳過當前這一輪的執行。",
                reference: "Python程式設計入門 - 第4章：continue語句",
                codeExample: "# continue vs break 示例\nfor i in range(5):\n    if i == 2:\n        continue  # 跳過i=2的輸出\n    print(f'continue例子: {i}')  # 輸出: 0,1,3,4\n\nfor i in range(5):\n    if i == 2:\n        break  # 在i=2時終止迴圈\n    print(f'break例子: {i}')  # 輸出: 0,1"
            },
            {
                question: "以下程式碼會輸出什麼？",
                code: `for i in range(3):
    for j in range(2):
        if i == 1 and j == 0:
            break
        print(f"{i},{j}")`,
                options: ["0,0 0,1 2,0 2,1", "0,0 0,1 1,1 2,0 2,1", "0,0 0,1 2,0 2,1", "0,0 0,1 1,0 2,0 2,1"],
                correct: 1,
                difficulty: "hard",
                topic: "控制結構",
                explanation: "巢狀迴圈中的break只會跳出最內層迴圈。當i=1,j=0時，break跳出內層迴圈，但外層迴圈繼續執行。所以會輸出：(0,0), (0,1), (1,1), (2,0), (2,1)。",
                reference: "Python官方文檔 - 巢狀迴圈控制",
                codeExample: "# 巢狀迴圈break示例\nfor outer in range(3):\n    print(f'外層迴圈: {outer}')\n    for inner in range(3):\n        if inner == 1:\n            print('  break內層迴圈')\n            break\n        print(f'  內層迴圈: {inner}')\n    print('外層迴圈繼續')"
            },
            {
                question: "Python中的三元運算符語法是什麼？",
                code: `x = 10
result = "positive" if x > 0 else "non-positive"
print(result)`,
                options: ["positive", "non-positive", "10", "錯誤"],
                correct: 0,
                difficulty: "medium",
                topic: "控制結構",
                explanation: "Python的三元運算符語法是：value_if_true if condition else value_if_false。這是if-else語句的簡化寫法，常用於簡單的條件賦值。",
                reference: "Python官方文檔 - 條件表達式",
                codeExample: "# 三元運算符示例\nage = 18\nstatus = '成年' if age >= 18 else '未成年'\nprint(status)\n\n# 等同於：\nif age >= 18:\n    status = '成年'\nelse:\n    status = '未成年'\n\n# 巢狀三元運算符\nscore = 85\ngrade = 'A' if score >= 90 else 'B' if score >= 80 else 'C'"
            },
            {
                question: "以下程式碼的輸出是什麼？",
                code: `numbers = [1, 2, 3, 4, 5]
for i, num in enumerate(numbers):
    if num % 2 == 0:
        print(f"Index {i}: {num}")`,
                options: ["Index 1: 2\nIndex 3: 4", "Index 0: 1\nIndex 2: 3\nIndex 4: 5", "2\n4", "1\n3\n5"],
                correct: 0,
                difficulty: "medium",
                topic: "控制結構",
                explanation: "enumerate()函數返回索引和值的配對。程式碼找出偶數並印出其索引和值。2在索引1，4在索引3，所以輸出'Index 1: 2'和'Index 3: 4'。",
                reference: "Python內建函數 - enumerate",
                codeExample: "# enumerate使用示例\nfruits = ['apple', 'banana', 'cherry']\n\n# 基本用法\nfor index, fruit in enumerate(fruits):\n    print(f'{index}: {fruit}')\n\n# 指定起始索引\nfor index, fruit in enumerate(fruits, start=1):\n    print(f'第{index}個水果: {fruit}')"
            },
            {
                question: "while-else語句的特殊行為是什麼？",
                code: `i = 0
while i < 3:
    print(i)
    i += 1
else:
    print("迴圈正常結束")`,
                options: ["else不會執行", "else會執行", "會產生錯誤", "無限迴圈"],
                correct: 1,
                difficulty: "hard",
                topic: "控制結構",
                explanation: "while-else中的else子句在迴圈正常結束時執行（即條件變為False時）。如果迴圈被break終止，else不會執行。這是Python獨有的特性。",
                reference: "Python官方文檔 - while-else語句",
                codeExample: "# while-else示例\n# 正常結束，else執行\ni = 0\nwhile i < 3:\n    print(f'正常: {i}')\n    i += 1\nelse:\n    print('正常結束，else執行')\n\n# break終止，else不執行\ni = 0\nwhile i < 10:\n    if i == 2:\n        break\n    print(f'中斷: {i}')\n    i += 1\nelse:\n    print('這行不會執行')"
            },
            {
                question: "以下程式碼會輸出什麼？",
                code: `for i in range(5):
    if i == 0:
        continue
    elif i == 3:
        break
    print(i)`,
                options: ["1 2", "0 1 2", "1 2 3", "0 1 2 3 4"],
                correct: 0,
                difficulty: "medium",
                topic: "控制結構",
                explanation: "i=0時continue跳過print，i=1,2時正常print，i=3時break終止迴圈。所以只輸出1和2。",
                reference: "Python控制流程 - continue和break組合",
                codeExample: "# 控制流程組合示例\nfor num in range(10):\n    if num < 2:  # 跳過0,1\n        continue\n    if num > 5:  # 大於5就停止\n        break\n    if num % 2 == 0:  # 只印偶數\n        print(f'偶數: {num}')\n# 輸出: 偶數: 2, 偶數: 4"
            },
            
            // 第4章：函數與模組 (250題)
            {
                question: "定義一個Python函數的正確語法是什麼？",
                options: ["function myFunc():", "def myFunc():", "func myFunc():", "define myFunc():"],
                correct: 1,
                difficulty: "easy",
                topic: "函數與模組",
                explanation: "Python使用 'def' 關鍵字來定義函數。",
                reference: "Python Crash Course 第2版 - 第8章：函數"
            },
            {
                question: "以下函數會返回什麼值？",
                code: `def calculate(a, b=5):
    return a * b

result = calculate(3)`,
                options: ["3", "5", "15", "8"],
                correct: 2,
                difficulty: "medium",
                topic: "函數與模組",
                explanation: "函數有預設參數 b=5，調用 calculate(3) 時，a=3, b=5，返回 3*5=15。",
                reference: "Python Crash Course 第2版 - 第8章：預設參數"
            },
            {
                question: "Python中的 *args 參數用於什麼？",
                options: ["接收關鍵字參數", "接收可變數量的位置參數", "接收字典參數", "接收列表參數"],
                correct: 1,
                difficulty: "hard",
                topic: "函數與模組",
                explanation: "*args 用於接收可變數量的位置參數，將它們打包成元組。",
                reference: "Python Crash Course 第2版 - 第8章：任意數量的參數"
            },
            {
                question: "以下程式碼會輸出什麼？",
                code: `def greet(name, greeting="Hello"):
    return f"{greeting}, {name}!"

print(greet("Alice"))`,
                options: ["Hello, Alice!", "Alice, Hello!", "greeting, Alice!", "錯誤"],
                correct: 0,
                difficulty: "medium",
                topic: "函數與模組",
                explanation: "函數使用預設參數greeting='Hello'，所以輸出'Hello, Alice!'。",
                reference: "Python Crash Course 第2版 - 第8章：預設參數值"
            },
            {
                question: "Python中的 **kwargs 參數用於什麼？",
                options: ["接收位置參數", "接收關鍵字參數", "接收列表參數", "接收元組參數"],
                correct: 1,
                difficulty: "hard",
                topic: "函數與模組",
                explanation: "**kwargs 用於接收可變數量的關鍵字參數，將它們打包成字典。kwargs是'keyword arguments'的縮寫，允許函數接受任意數量的關鍵字參數。",
                reference: "Python Crash Course 第2版 - 第8章：任意數量的關鍵字參數",
                codeExample: "# **kwargs 示例\ndef print_info(**kwargs):\n    for key, value in kwargs.items():\n        print(f'{key}: {value}')\n\n# 調用方式\nprint_info(name='Alice', age=25, city='Taipei')\n# 輸出:\n# name: Alice\n# age: 25\n# city: Taipei"
            },
            {
                question: "以下程式碼會輸出什麼？",
                code: `def modify_list(lst=[]):
    lst.append(1)
    return lst

result1 = modify_list()
result2 = modify_list()
print(result1, result2)`,
                options: ["[1] [1]", "[1] [1, 1]", "[] []", "錯誤"],
                correct: 1,
                difficulty: "hard",
                topic: "函數與模組",
                explanation: "這是Python的「可變預設參數陷阱」。預設參數[]在函數定義時創建，每次調用都使用同一個列表物件。第一次調用後列表變成[1]，第二次調用時在同一個列表上再加1，變成[1,1]。",
                reference: "Python陷阱 - 可變預設參數",
                codeExample: "# 正確的寫法\ndef modify_list_correct(lst=None):\n    if lst is None:\n        lst = []  # 每次都創建新列表\n    lst.append(1)\n    return lst\n\n# 或者\ndef modify_list_correct2(lst=None):\n    lst = lst or []  # 使用or運算符\n    lst.append(1)\n    return lst"
            },
            {
                question: "Python中的lambda函數有什麼特點？",
                code: `square = lambda x: x ** 2
numbers = [1, 2, 3, 4, 5]
result = list(map(square, numbers))
print(result)`,
                options: ["[1, 2, 3, 4, 5]", "[1, 4, 9, 16, 25]", "[2, 4, 6, 8, 10]", "錯誤"],
                correct: 1,
                difficulty: "medium",
                topic: "函數與模組",
                explanation: "lambda是匿名函數，語法是 lambda 參數: 表達式。這裡lambda x: x**2 等同於 def square(x): return x**2。map()函數將lambda應用到每個元素上。",
                reference: "Python官方文檔 - lambda表達式",
                codeExample: "# lambda vs 普通函數\n# 使用lambda\nsquare_lambda = lambda x: x ** 2\n\n# 等同的普通函數\ndef square_function(x):\n    return x ** 2\n\n# 常見用法：與map, filter, sorted一起使用\nnumbers = [1, 2, 3, 4, 5]\nsquared = list(map(lambda x: x**2, numbers))\neven = list(filter(lambda x: x%2==0, numbers))\nsorted_desc = sorted(numbers, key=lambda x: -x)"
            },
            {
                question: "Python中的裝飾器(decorator)是什麼？",
                code: `def my_decorator(func):
    def wrapper():
        print("Before function")
        func()
        print("After function")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()`,
                options: ["只輸出Hello!", "Before function\nHello!\nAfter function", "錯誤", "After function\nHello!\nBefore function"],
                correct: 1,
                difficulty: "hard",
                topic: "函數與模組",
                explanation: "裝飾器是修改或擴展函數行為的語法糖。@my_decorator等同於say_hello = my_decorator(say_hello)。裝飾器包裝原函數，可以在執行前後添加額外功能。",
                reference: "Python進階 - 裝飾器模式",
                codeExample: "# 裝飾器示例\ndef timer_decorator(func):\n    import time\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        end = time.time()\n        print(f'{func.__name__} 執行時間: {end-start:.4f}秒')\n        return result\n    return wrapper\n\n@timer_decorator\ndef slow_function():\n    import time\n    time.sleep(1)\n    return 'Done'"
            },
            {
                question: "以下程式碼的輸出是什麼？",
                code: `def outer_function(x):
    def inner_function(y):
        return x + y
    return inner_function

add_10 = outer_function(10)
result = add_10(5)
print(result)`,
                options: ["15", "10", "5", "錯誤"],
                correct: 0,
                difficulty: "hard",
                topic: "函數與模組",
                explanation: "這展示了Python的閉包(closure)概念。inner_function記住了外部函數的變數x=10。當outer_function(10)返回inner_function時，x的值被保存。後來調用add_10(5)時，x=10, y=5，返回15。",
                reference: "Python進階 - 閉包與作用域",
                codeExample: "# 閉包示例\ndef make_multiplier(n):\n    def multiplier(x):\n        return x * n  # n來自外部作用域\n    return multiplier\n\n# 創建不同的乘法器\ndouble = make_multiplier(2)\ntriple = make_multiplier(3)\n\nprint(double(5))  # 10\nprint(triple(5))  # 15\n\n# 檢查閉包變數\nprint(double.__closure__[0].cell_contents)  # 2"
            },
            {
                question: "Python模組的導入方式有哪些？",
                options: ["只有import module", "import module 和 from module import *", "import, from...import, import...as", "只有from module import function"],
                correct: 2,
                difficulty: "medium",
                topic: "函數與模組",
                explanation: "Python有多種導入方式：1) import module 2) from module import function 3) import module as alias 4) from module import * (不推薦)。每種方式都有不同的命名空間影響。",
                reference: "Python官方文檔 - 模組系統",
                codeExample: "# 不同的導入方式\n# 1. 基本導入\nimport math\nprint(math.pi)\n\n# 2. 導入特定函數\nfrom math import pi, sqrt\nprint(pi)\n\n# 3. 使用別名\nimport math as m\nprint(m.e)\n\n# 4. 導入所有（不推薦）\n# from math import *\n\n# 5. 相對導入（在包中）\n# from .module import function\n# from ..parent import function"
            },
            
            // 第5章：物件導向程式設計 (280題)
            {
                question: "Python中定義類別的關鍵字是什麼？",
                options: ["class", "Class", "object", "Object"],
                correct: 0,
                difficulty: "easy",
                topic: "物件導向程式設計",
                explanation: "Python使用 'class' 關鍵字來定義類別。",
                reference: "Python Crash Course 第2版 - 第9章：類別"
            },
            {
                question: "以下程式碼會輸出什麼？",
                code: `class Dog:
    def __init__(self, name):
        self.name = name
    
    def bark(self):
        return f"{self.name} says Woof!"

my_dog = Dog("Buddy")
print(my_dog.bark())`,
                options: ["Buddy", "Woof!", "Buddy says Woof!", "Dog says Woof!"],
                correct: 2,
                difficulty: "medium",
                topic: "物件導向程式設計",
                explanation: "建立Dog物件時name設為'Buddy'，bark()方法返回格式化字串。",
                reference: "Python Crash Course 第2版 - 第9章：類別和方法"
            },
            {
                question: "Python中的繼承使用什麼語法？",
                options: ["class Child extends Parent:", "class Child(Parent):", "class Child inherits Parent:", "class Child -> Parent:"],
                correct: 1,
                difficulty: "medium",
                topic: "物件導向程式設計",
                explanation: "Python使用括號語法來表示繼承關係：class Child(Parent):",
                reference: "Python Crash Course 第2版 - 第9章：繼承"
            },
            {
                question: "__init__ 方法的作用是什麼？",
                options: ["刪除物件", "初始化物件", "複製物件", "比較物件"],
                correct: 1,
                difficulty: "easy",
                topic: "物件導向程式設計",
                explanation: "__init__ 是建構子方法，用於初始化新建立的物件。",
                reference: "Python程式設計入門 - 第8章：類別初始化"
            },
            {
                question: "以下程式碼中，self參數的作用是什麼？",
                code: `class Car:
    def __init__(self, brand):
        self.brand = brand`,
                options: ["表示類別本身", "表示物件實例", "表示父類別", "表示方法"],
                correct: 1,
                difficulty: "medium",
                topic: "物件導向程式設計",
                explanation: "self參數代表物件實例本身，用於存取實例的屬性和方法。在Python中，self必須是實例方法的第一個參數，但調用時不需要傳遞。",
                reference: "Python Crash Course 第2版 - 第9章：self參數",
                codeExample: "# self參數示例\nclass Person:\n    def __init__(self, name):\n        self.name = name  # self.name是實例屬性\n    \n    def greet(self):\n        return f'Hello, I am {self.name}'  # 使用self存取屬性\n\n# 使用\nperson = Person('Alice')\nprint(person.greet())  # 調用時不需要傳遞self"
            },
            {
                question: "Python中的類別變數和實例變數有什麼差別？",
                code: `class Counter:
    count = 0  # 類別變數
    
    def __init__(self):
        Counter.count += 1
        self.instance_id = Counter.count  # 實例變數

c1 = Counter()
c2 = Counter()
print(Counter.count, c1.instance_id, c2.instance_id)`,
                options: ["2 1 2", "1 1 1", "0 1 2", "2 2 2"],
                correct: 0,
                difficulty: "hard",
                topic: "物件導向程式設計",
                explanation: "類別變數被所有實例共享，實例變數屬於特定實例。每次創建實例時count增加，c1的instance_id是1，c2的是2，最終count是2。",
                reference: "Python官方文檔 - 類別和實例變數",
                codeExample: "# 類別變數 vs 實例變數\nclass Student:\n    school = 'Python大學'  # 類別變數，所有實例共享\n    \n    def __init__(self, name):\n        self.name = name  # 實例變數，每個實例獨有\n\ns1 = Student('Alice')\ns2 = Student('Bob')\n\nprint(s1.school)  # Python大學\nprint(s2.school)  # Python大學\nprint(s1.name)    # Alice\nprint(s2.name)    # Bob\n\n# 修改類別變數影響所有實例\nStudent.school = 'Java大學'\nprint(s1.school)  # Java大學"
            },
            {
                question: "Python中的方法重寫(method overriding)是什麼？",
                code: `class Animal:
    def make_sound(self):
        return "Some sound"

class Dog(Animal):
    def make_sound(self):
        return "Woof!"

dog = Dog()
print(dog.make_sound())`,
                options: ["Some sound", "Woof!", "錯誤", "Some sound Woof!"],
                correct: 1,
                difficulty: "medium",
                topic: "物件導向程式設計",
                explanation: "方法重寫是子類別重新定義父類別的方法。Dog類別重寫了Animal的make_sound方法，所以調用時執行子類別的版本。",
                reference: "Python官方文檔 - 方法重寫",
                codeExample: "# 方法重寫示例\nclass Vehicle:\n    def start(self):\n        return '車輛啟動'\n    \n    def stop(self):\n        return '車輛停止'\n\nclass Car(Vehicle):\n    def start(self):  # 重寫父類別方法\n        return '汽車引擎啟動'\n    \n    # stop方法繼承自父類別\n\nclass Bicycle(Vehicle):\n    def start(self):  # 重寫父類別方法\n        return '開始踩踏板'\n\ncar = Car()\nbike = Bicycle()\nprint(car.start())   # 汽車引擎啟動\nprint(bike.start())  # 開始踩踏板\nprint(car.stop())    # 車輛停止（繼承）"
            },
            {
                question: "Python中的super()函數有什麼作用？",
                code: `class Parent:
    def __init__(self, name):
        self.name = name

class Child(Parent):
    def __init__(self, name, age):
        super().__init__(name)
        self.age = age

child = Child("Alice", 10)
print(child.name, child.age)`,
                options: ["Alice 10", "錯誤", "None 10", "Alice None"],
                correct: 0,
                difficulty: "medium",
                topic: "物件導向程式設計",
                explanation: "super()用於調用父類別的方法。super().__init__(name)調用父類別的建構子，設定name屬性，然後子類別再設定age屬性。",
                reference: "Python官方文檔 - super()函數",
                codeExample: "# super()使用示例\nclass Animal:\n    def __init__(self, species):\n        self.species = species\n        print(f'Animal初始化: {species}')\n    \n    def info(self):\n        return f'我是{self.species}'\n\nclass Dog(Animal):\n    def __init__(self, species, breed):\n        super().__init__(species)  # 調用父類別建構子\n        self.breed = breed\n        print(f'Dog初始化: {breed}')\n    \n    def info(self):\n        parent_info = super().info()  # 調用父類別方法\n        return f'{parent_info}，品種是{self.breed}'\n\ndog = Dog('犬類', '黃金獵犬')\nprint(dog.info())"
            },
            {
                question: "Python中的私有屬性和方法如何定義？",
                code: `class BankAccount:
    def __init__(self, balance):
        self.__balance = balance  # 私有屬性
    
    def __validate(self):  # 私有方法
        return self.__balance >= 0
    
    def get_balance(self):
        return self.__balance

account = BankAccount(1000)
print(account.get_balance())
# print(account.__balance)  # 這行會發生什麼？`,
                options: ["1000，第二行正常執行", "1000，第二行會錯誤", "錯誤", "0"],
                correct: 1,
                difficulty: "hard",
                topic: "物件導向程式設計",
                explanation: "Python使用雙底線__開頭表示私有屬性/方法。這會觸發名稱修飾(name mangling)，外部無法直接存取。account.__balance會引發AttributeError。",
                reference: "Python官方文檔 - 私有變數",
                codeExample: "# 私有屬性示例\nclass SecretBox:\n    def __init__(self):\n        self.public = '公開資料'\n        self._protected = '受保護資料'  # 慣例：單底線表示內部使用\n        self.__private = '私有資料'    # 雙底線表示私有\n    \n    def show_private(self):\n        return self.__private\n\nbox = SecretBox()\nprint(box.public)        # OK\nprint(box._protected)    # OK（但不建議）\n# print(box.__private)   # AttributeError\nprint(box.show_private()) # OK，通過方法存取\n\n# 實際上可以這樣存取（但不應該）\nprint(box._SecretBox__private)  # 名稱修飾後的真實名稱"
            },
            {
                question: "Python中的多重繼承是什麼？",
                code: `class A:
    def method(self):
        print("A")

class B:
    def method(self):
        print("B")

class C(A, B):
    pass

c = C()
c.method()`,
                options: ["A", "B", "A B", "錯誤"],
                correct: 0,
                difficulty: "hard",
                topic: "物件導向程式設計",
                explanation: "Python支援多重繼承。當有方法名稱衝突時，使用MRO(Method Resolution Order)決定調用順序。C(A, B)表示A在B之前，所以調用A的method。",
                reference: "Python官方文檔 - 多重繼承和MRO",
                codeExample: "# 多重繼承和MRO示例\nclass Animal:\n    def speak(self):\n        print('動物叫聲')\n\nclass Mammal:\n    def speak(self):\n        print('哺乳動物叫聲')\n    \n    def feed_milk(self):\n        print('餵奶')\n\nclass Dog(Animal, Mammal):\n    pass\n\ndog = Dog()\ndog.speak()      # 動物叫聲（Animal在前）\ndog.feed_milk()  # 餵奶（從Mammal繼承）\n\n# 查看MRO\nprint(Dog.__mro__)\n# (<class '__main__.Dog'>, <class '__main__.Animal'>, \n#  <class '__main__.Mammal'>, <class 'object'>)"
            },
            
            // 第6章：檔案處理與異常處理 (200題)
            {
                question: "開啟檔案進行讀取的正確方式是什麼？",
                options: ["open('file.txt', 'w')", "open('file.txt', 'r')", "open('file.txt', 'a')", "open('file.txt', 'x')"],
                correct: 1,
                difficulty: "easy",
                topic: "檔案處理與異常處理",
                explanation: "'r' 模式用於讀取檔案，'w'用於寫入，'a'用於附加，'x'用於獨佔建立。",
                reference: "Python Crash Course 第2版 - 第10章：檔案和異常"
            },
            {
                question: "try-except語句的作用是什麼？",
                options: ["執行迴圈", "定義函數", "處理異常", "建立類別"],
                correct: 2,
                difficulty: "easy",
                topic: "檔案處理與異常處理",
                explanation: "try-except語句用於捕獲和處理程式執行時可能發生的異常。",
                reference: "Python Crash Course 第2版 - 第10章：異常處理"
            },
            {
                question: "以下程式碼會發生什麼？",
                code: `try:
    result = 10 / 0
except ZeroDivisionError:
    print("Cannot divide by zero")
except Exception as e:
    print(f"Error: {e}")`,
                options: ["程式崩潰", "輸出 'Cannot divide by zero'", "輸出 'Error: division by zero'", "沒有輸出"],
                correct: 1,
                difficulty: "medium",
                topic: "檔案處理與異常處理",
                explanation: "除以零會引發ZeroDivisionError，被第一個except捕獲。",
                reference: "Python Crash Course 第2版 - 第10章：特定異常"
            },
            {
                question: "with語句在檔案處理中的優點是什麼？",
                options: ["提高讀取速度", "自動關閉檔案", "減少記憶體使用", "防止檔案損壞"],
                correct: 1,
                difficulty: "medium",
                topic: "檔案處理與異常處理",
                explanation: "with語句會自動管理檔案的開啟和關閉，即使發生異常也會正確關閉檔案。",
                reference: "Automate the Boring Stuff with Python - 第8章：檔案處理"
            },
            {
                question: "finally語句的作用是什麼？",
                options: ["只在沒有異常時執行", "只在有異常時執行", "無論是否有異常都執行", "終止程式"],
                correct: 2,
                difficulty: "medium",
                topic: "檔案處理與異常處理",
                explanation: "finally語句中的程式碼無論是否發生異常都會執行，通常用於清理資源。即使在try或except中有return語句，finally也會執行。",
                reference: "Python程式設計入門 - 第7章：finally語句",
                codeExample: "# finally語句示例\ndef test_finally():\n    try:\n        print('try區塊')\n        return 'try返回值'\n    except:\n        print('except區塊')\n        return 'except返回值'\n    finally:\n        print('finally區塊總是執行')  # 即使有return也會執行\n\nresult = test_finally()\nprint(f'函數返回: {result}')\n\n# 輸出:\n# try區塊\n# finally區塊總是執行\n# 函數返回: try返回值"
            },
            {
                question: "以下程式碼會發生什麼？",
                code: `try:
    with open('nonexistent.txt', 'r') as file:
        content = file.read()
except FileNotFoundError as e:
    print(f"檔案不存在: {e}")
except PermissionError as e:
    print(f"權限錯誤: {e}")
except Exception as e:
    print(f"其他錯誤: {e}")`,
                options: ["檔案不存在訊息", "權限錯誤訊息", "其他錯誤訊息", "程式崩潰"],
                correct: 0,
                difficulty: "medium",
                topic: "檔案處理與異常處理",
                explanation: "當檔案不存在時，open()會引發FileNotFoundError。異常處理按順序檢查，第一個匹配的except子句會被執行。",
                reference: "Python官方文檔 - 異常層次結構",
                codeExample: "# 異常處理層次示例\nimport os\n\ndef safe_file_operation(filename):\n    try:\n        with open(filename, 'r') as f:\n            return f.read()\n    except FileNotFoundError:\n        return f'檔案 {filename} 不存在'\n    except PermissionError:\n        return f'沒有權限讀取 {filename}'\n    except IsADirectoryError:\n        return f'{filename} 是目錄，不是檔案'\n    except Exception as e:\n        return f'未預期的錯誤: {type(e).__name__}: {e}'\n\n# 測試不同情況\nprint(safe_file_operation('nonexistent.txt'))\nprint(safe_file_operation('/etc/shadow'))  # 權限問題\nprint(safe_file_operation('/'))  # 目錄問題"
            },
            {
                question: "Python中的自定義異常如何創建？",
                code: `class CustomError(Exception):
    def __init__(self, message):
        self.message = message
        super().__init__(self.message)

def validate_age(age):
    if age < 0:
        raise CustomError("年齡不能為負數")
    if age > 150:
        raise CustomError("年齡不能超過150歲")
    return True

try:
    validate_age(-5)
except CustomError as e:
    print(f"驗證錯誤: {e}")`,
                options: ["驗證錯誤: 年齡不能為負數", "驗證錯誤: 年齡不能超過150歲", "程式崩潰", "沒有輸出"],
                correct: 0,
                difficulty: "hard",
                topic: "檔案處理與異常處理",
                explanation: "自定義異常通過繼承Exception類創建。validate_age(-5)觸發第一個條件，引發CustomError異常，被except捕獲並輸出錯誤訊息。",
                reference: "Python官方文檔 - 自定義異常",
                codeExample: "# 自定義異常示例\nclass ValidationError(Exception):\n    \"\"\"驗證錯誤的基類\"\"\"\n    pass\n\nclass AgeError(ValidationError):\n    \"\"\"年齡相關錯誤\"\"\"\n    def __init__(self, age, message=None):\n        self.age = age\n        if message is None:\n            message = f'無效的年齡: {age}'\n        super().__init__(message)\n\nclass EmailError(ValidationError):\n    \"\"\"電子郵件相關錯誤\"\"\"\n    pass\n\ndef validate_user(age, email):\n    if not 0 <= age <= 120:\n        raise AgeError(age)\n    if '@' not in email:\n        raise EmailError(f'無效的電子郵件: {email}')\n    return True\n\n# 使用自定義異常\ntry:\n    validate_user(-1, 'invalid-email')\nexcept AgeError as e:\n    print(f'年齡錯誤: {e}')\nexcept EmailError as e:\n    print(f'郵件錯誤: {e}')\nexcept ValidationError as e:\n    print(f'驗證錯誤: {e}')"
            },
            {
                question: "以下程式碼的輸出是什麼？",
                code: `import json

data = {'name': '張三', 'age': 30, 'city': '台北'}

try:
    json_string = json.dumps(data, ensure_ascii=False)
    parsed_data = json.loads(json_string)
    print(parsed_data['name'])
except json.JSONDecodeError as e:
    print(f"JSON錯誤: {e}")
except KeyError as e:
    print(f"鍵錯誤: {e}")`,
                options: ["張三", "JSON錯誤", "鍵錯誤", "程式崩潰"],
                correct: 0,
                difficulty: "medium",
                topic: "檔案處理與異常處理",
                explanation: "程式碼正常執行：將字典轉為JSON字串，再解析回字典，然後輸出name鍵的值'張三'。ensure_ascii=False確保中文字符正確顯示。",
                reference: "Python標準庫 - json模組",
                codeExample: "# JSON處理示例\nimport json\n\n# 複雜的資料結構\ndata = {\n    'users': [\n        {'name': '王小明', 'age': 25, 'hobbies': ['讀書', '游泳']},\n        {'name': '李小華', 'age': 30, 'hobbies': ['電影', '旅行']}\n    ],\n    'total': 2\n}\n\ntry:\n    # 序列化為JSON\n    json_str = json.dumps(data, ensure_ascii=False, indent=2)\n    print('JSON字串:')\n    print(json_str)\n    \n    # 反序列化\n    parsed = json.loads(json_str)\n    print(f'\\n第一個用戶: {parsed[\"users\"][0][\"name\"]}')\n    \nexcept json.JSONDecodeError as e:\n    print(f'JSON解析錯誤: {e}')\nexcept (KeyError, IndexError) as e:\n    print(f'資料存取錯誤: {e}')"
            },
            {
                question: "Python中的上下文管理器(context manager)是什麼？",
                code: `class MyContextManager:
    def __enter__(self):
        print("進入上下文")
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        print("離開上下文")
        return False

with MyContextManager() as cm:
    print("在上下文中")`,
                options: ["只輸出'在上下文中'", "進入上下文\\n在上下文中\\n離開上下文", "錯誤", "沒有輸出"],
                correct: 1,
                difficulty: "hard",
                topic: "檔案處理與異常處理",
                explanation: "上下文管理器實現__enter__和__exit__方法，配合with語句使用。進入時調用__enter__，離開時調用__exit__，確保資源正確清理。",
                reference: "Python官方文檔 - 上下文管理器",
                codeExample: "# 實用的上下文管理器示例\nimport time\n\nclass Timer:\n    def __enter__(self):\n        self.start = time.time()\n        print('開始計時')\n        return self\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.end = time.time()\n        print(f'執行時間: {self.end - self.start:.4f}秒')\n        return False  # 不抑制異常\n\n# 使用計時器\nwith Timer():\n    # 模擬一些工作\n    sum(range(1000000))\n    print('工作完成')\n\n# 也可以用contextlib.contextmanager裝飾器\nfrom contextlib import contextmanager\n\n@contextmanager\ndef file_manager(filename, mode):\n    print(f'開啟檔案: {filename}')\n    f = open(filename, mode)\n    try:\n        yield f\n    finally:\n        print(f'關閉檔案: {filename}')\n        f.close()"
            },
            {
                question: "以下程式碼會輸出什麼？",
                code: `def risky_function():
    try:
        return 1/0
    except ZeroDivisionError:
        return "除零錯誤"
    finally:
        return "finally返回"

result = risky_function()
print(result)`,
                options: ["除零錯誤", "finally返回", "錯誤", "1/0的結果"],
                correct: 1,
                difficulty: "hard",
                topic: "檔案處理與異常處理",
                explanation: "finally中的return會覆蓋try和except中的return。雖然except捕獲了異常並要返回'除零錯誤'，但finally的return會覆蓋它，最終返回'finally返回'。",
                reference: "Python官方文檔 - finally語句的特殊行為",
                codeExample: "# finally return的影響\ndef test_returns():\n    try:\n        print('try區塊')\n        return 'try返回'\n    except:\n        print('except區塊')\n        return 'except返回'\n    finally:\n        print('finally區塊')\n        # 注意：finally中的return會覆蓋其他return\n        # return 'finally返回'  # 如果取消註解，會覆蓋try的return\n\nresult = test_returns()\nprint(f'最終結果: {result}')\n\n# 更好的做法：在finally中不使用return\ndef better_function():\n    result = None\n    try:\n        result = 'try成功'\n        return result\n    except Exception as e:\n        result = f'異常: {e}'\n        return result\n    finally:\n        print(f'清理工作，結果是: {result}')\n        # 不在finally中return"
            },
            
            // 第7章：資料結構與演算法 (300題)
            {
                question: "Python中的列表(list)和元組(tuple)的主要差別是什麼？",
                options: ["列表可變，元組不可變", "列表不可變，元組可變", "沒有差別", "只有語法不同"],
                correct: 0,
                difficulty: "easy",
                topic: "資料結構與演算法",
                explanation: "列表是可變的資料結構，可以修改元素；元組是不可變的。",
                reference: "Python Crash Course 第2版 - 第4章：列表vs元組"
            },
            {
                question: "以下哪個方法可以將兩個列表合併？",
                options: ["list1.append(list2)", "list1.extend(list2)", "list1.insert(list2)", "list1.remove(list2)"],
                correct: 1,
                difficulty: "medium",
                topic: "資料結構與演算法",
                explanation: "extend()方法將另一個列表的所有元素添加到當前列表中。",
                reference: "Python Crash Course 第2版 - 第3章：列表方法"
            },
            {
                question: "Python中的集合(set)有什麼特性？",
                options: ["有序且允許重複", "無序且允許重複", "有序且不允許重複", "無序且不允許重複"],
                correct: 3,
                difficulty: "medium",
                topic: "資料結構與演算法",
                explanation: "集合是無序的，且不允許重複元素的資料結構。",
                reference: "Python程式設計入門 - 第5章：集合"
            },
            {
                question: "以下程式碼會輸出什麼？",
                code: `numbers = [3, 1, 4, 1, 5, 9, 2, 6]
numbers.sort()
print(numbers[:3])`,
                options: ["[3, 1, 4]", "[1, 1, 2]", "[6, 9, 5]", "[2, 9, 6]"],
                correct: 1,
                difficulty: "medium",
                topic: "資料結構與演算法",
                explanation: "sort()方法會將列表排序為[1, 1, 2, 3, 4, 5, 6, 9]，[:3]取前三個元素。",
                reference: "Python Crash Course 第2版 - 第3章：列表排序"
            },
            {
                question: "字典的keys()方法返回什麼？",
                options: ["列表", "元組", "字典視圖物件", "集合"],
                correct: 2,
                difficulty: "medium",
                topic: "資料結構與演算法",
                explanation: "keys()方法返回一個字典視圖物件，包含字典的所有鍵。視圖物件是動態的，會反映字典的變化，可以進行集合運算。",
                reference: "Python Crash Course 第2版 - 第6章：字典方法",
                codeExample: "# 字典視圖物件示例\ndata = {'a': 1, 'b': 2, 'c': 3}\n\n# 獲取視圖物件\nkeys_view = data.keys()\nvalues_view = data.values()\nitems_view = data.items()\n\nprint(f'鍵視圖: {keys_view}')\nprint(f'值視圖: {values_view}')\nprint(f'項目視圖: {items_view}')\n\n# 視圖是動態的\ndata['d'] = 4\nprint(f'添加後的鍵: {keys_view}')  # 自動更新\n\n# 視圖可以進行集合運算\nother_dict = {'b': 20, 'c': 30, 'e': 50}\ncommon_keys = data.keys() & other_dict.keys()\nprint(f'共同鍵: {common_keys}')  # {'b', 'c'}"
            },
            {
                question: "以下程式碼會輸出什麼？",
                code: `from collections import Counter

text = "hello world"
counter = Counter(text)
print(counter.most_common(3))`,
                options: ["[('l', 3), ('o', 2), ('h', 1)]", "[('h', 1), ('e', 1), ('l', 3)]", "[('l', 3), ('o', 2), (' ', 1)]", "錯誤"],
                correct: 0,
                difficulty: "medium",
                topic: "資料結構與演算法",
                explanation: "Counter統計字符出現次數，most_common(3)返回出現次數最多的3個元素。'l'出現3次，'o'出現2次，其他字符出現1次。",
                reference: "Python標準庫 - collections.Counter",
                codeExample: "# Counter使用示例\nfrom collections import Counter\n\n# 統計字符\ntext = 'programming'\nchar_count = Counter(text)\nprint(f'字符統計: {char_count}')\nprint(f'最常見的2個: {char_count.most_common(2)}')\n\n# 統計單詞\nwords = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple']\nword_count = Counter(words)\nprint(f'單詞統計: {word_count}')\n\n# Counter運算\ncount1 = Counter('aab')\ncount2 = Counter('abc')\nprint(f'相加: {count1 + count2}')\nprint(f'相減: {count1 - count2}')\nprint(f'交集: {count1 & count2}')\nprint(f'聯集: {count1 | count2}')"
            },
            {
                question: "Python中的deque(雙端佇列)有什麼優勢？",
                code: `from collections import deque

dq = deque([1, 2, 3])
dq.appendleft(0)
dq.append(4)
print(list(dq))`,
                options: ["[0, 1, 2, 3, 4]", "[1, 2, 3, 0, 4]", "[4, 0, 1, 2, 3]", "錯誤"],
                correct: 0,
                difficulty: "medium",
                topic: "資料結構與演算法",
                explanation: "deque支援兩端的高效插入和刪除操作。appendleft(0)在左端插入0，append(4)在右端插入4，結果是[0, 1, 2, 3, 4]。",
                reference: "Python標準庫 - collections.deque",
                codeExample: "# deque vs list 性能比較\nfrom collections import deque\nimport time\n\n# deque在兩端操作很快\ndq = deque()\nstart = time.time()\nfor i in range(100000):\n    dq.appendleft(i)  # O(1)\ndeque_time = time.time() - start\n\n# list在左端插入很慢\nlst = []\nstart = time.time()\nfor i in range(100000):\n    lst.insert(0, i)  # O(n)\nlist_time = time.time() - start\n\nprint(f'deque左端插入時間: {deque_time:.4f}秒')\nprint(f'list左端插入時間: {list_time:.4f}秒')\n\n# deque的其他功能\ndq = deque([1, 2, 3, 4, 5], maxlen=3)  # 限制長度\ndq.append(6)  # 自動移除左端元素\nprint(f'限制長度的deque: {list(dq)}')  # [4, 5, 6]\n\ndq.rotate(1)  # 向右旋轉\nprint(f'旋轉後: {list(dq)}')  # [6, 4, 5]"
            },
            {
                question: "以下程式碼實現了什麼排序演算法？",
                code: `def mystery_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

print(mystery_sort([64, 34, 25, 12, 22, 11, 90]))`,
                options: ["快速排序", "合併排序", "泡沫排序", "插入排序"],
                correct: 2,
                difficulty: "hard",
                topic: "資料結構與演算法",
                explanation: "這是泡沫排序演算法。通過相鄰元素的比較和交換，較大的元素逐漸'冒泡'到數組末尾。時間複雜度O(n²)。",
                reference: "演算法導論 - 排序演算法",
                codeExample: "# 各種排序演算法比較\n\n# 1. 泡沫排序 O(n²)\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                swapped = True\n        if not swapped:  # 優化：如果沒有交換，已排序\n            break\n    return arr\n\n# 2. 選擇排序 O(n²)\ndef selection_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        min_idx = i\n        for j in range(i+1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr\n\n# 3. 插入排序 O(n²)\ndef insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr\n\n# 測試\ntest_data = [64, 34, 25, 12, 22, 11, 90]\nprint(f'泡沫排序: {bubble_sort(test_data.copy())}')\nprint(f'選擇排序: {selection_sort(test_data.copy())}')\nprint(f'插入排序: {insertion_sort(test_data.copy())}')"
            },
            {
                question: "Python中的生成器(generator)有什麼優勢？",
                code: `def fibonacci_generator(n):
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

fib = fibonacci_generator(5)
print(list(fib))`,
                options: ["[0, 1, 1, 2, 3]", "[1, 1, 2, 3, 5]", "[0, 1, 2, 3, 4]", "錯誤"],
                correct: 0,
                difficulty: "hard",
                topic: "資料結構與演算法",
                explanation: "生成器使用yield關鍵字，惰性求值，節省記憶體。fibonacci_generator生成前5個費波那契數：0, 1, 1, 2, 3。",
                reference: "Python官方文檔 - 生成器",
                codeExample: "# 生成器 vs 列表比較\n\n# 記憶體效率比較\ndef large_sequence_list(n):\n    \"\"\"返回列表，佔用大量記憶體\"\"\"\n    return [i**2 for i in range(n)]\n\ndef large_sequence_generator(n):\n    \"\"\"返回生成器，節省記憶體\"\"\"\n    for i in range(n):\n        yield i**2\n\n# 使用生成器表達式\nsquares_gen = (x**2 for x in range(10))\nprint(f'生成器物件: {squares_gen}')\nprint(f'生成器內容: {list(squares_gen)}')\n\n# 無限生成器\ndef infinite_counter(start=0):\n    while True:\n        yield start\n        start += 1\n\n# 只取前5個\ncounter = infinite_counter(10)\nfor i, value in enumerate(counter):\n    if i >= 5:\n        break\n    print(f'第{i+1}個值: {value}')\n\n# 生成器管道\ndef numbers():\n    for i in range(10):\n        yield i\n\ndef squares(nums):\n    for num in nums:\n        yield num ** 2\n\ndef evens(nums):\n    for num in nums:\n        if num % 2 == 0:\n            yield num\n\n# 組合生成器\nresult = evens(squares(numbers()))\nprint(f'偶數平方: {list(result)}')"
            },
            {
                question: "以下程式碼實現了什麼資料結構？",
                code: `class Stack:
    def __init__(self):
        self.items = []
    
    def push(self, item):
        self.items.append(item)
    
    def pop(self):
        return self.items.pop()
    
    def is_empty(self):
        return len(self.items) == 0

stack = Stack()
stack.push(1)
stack.push(2)
print(stack.pop())`,
                options: ["佇列(Queue)", "堆疊(Stack)", "鏈結串列(Linked List)", "樹(Tree)"],
                correct: 1,
                difficulty: "easy",
                topic: "資料結構與演算法",
                explanation: "這實現了堆疊(Stack)資料結構，遵循LIFO(Last In, First Out)原則。最後放入的元素最先取出，所以pop()返回2。",
                reference: "資料結構與演算法 - 堆疊",
                codeExample: "# 完整的堆疊實現\nclass Stack:\n    def __init__(self):\n        self.items = []\n    \n    def push(self, item):\n        \"\"\"將元素推入堆疊頂部\"\"\"\n        self.items.append(item)\n    \n    def pop(self):\n        \"\"\"從堆疊頂部彈出元素\"\"\"\n        if self.is_empty():\n            raise IndexError('pop from empty stack')\n        return self.items.pop()\n    \n    def peek(self):\n        \"\"\"查看堆疊頂部元素但不移除\"\"\"\n        if self.is_empty():\n            raise IndexError('peek from empty stack')\n        return self.items[-1]\n    \n    def is_empty(self):\n        \"\"\"檢查堆疊是否為空\"\"\"\n        return len(self.items) == 0\n    \n    def size(self):\n        \"\"\"返回堆疊大小\"\"\"\n        return len(self.items)\n    \n    def __str__(self):\n        return f'Stack({self.items})'\n\n# 堆疊的應用：括號匹配\ndef is_balanced(expression):\n    stack = Stack()\n    pairs = {'(': ')', '[': ']', '{': '}'}\n    \n    for char in expression:\n        if char in pairs:  # 開括號\n            stack.push(char)\n        elif char in pairs.values():  # 閉括號\n            if stack.is_empty():\n                return False\n            if pairs[stack.pop()] != char:\n                return False\n    \n    return stack.is_empty()\n\n# 測試\nprint(is_balanced('()[]{}'))     # True\nprint(is_balanced('([{}])'))     # True\nprint(is_balanced('([)]'))       # False"
            },
        ];

        // 初始化主題選項
        function initializeTopics() {
            const topicCounts = {};
            questionBank.forEach(q => {
                topicCounts[q.topic] = (topicCounts[q.topic] || 0) + 1;
            });
            
            const topics = Object.keys(topicCounts);
            const topicGrid = document.getElementById('topicGrid');
            topicGrid.innerHTML = '';
            
            topics.forEach(topic => {
                const topicItem = document.createElement('div');
                topicItem.className = 'topic-item selected';
                topicItem.innerHTML = `
                    <input type="checkbox" id="topic-${topic}" checked onchange="toggleTopic('${topic}')">
                    <div class="topic-info">
                        <div class="topic-name">${topic}</div>
                        <div class="topic-count">${topicCounts[topic]} 題</div>
                    </div>
                `;
                topicGrid.appendChild(topicItem);
            });
            
            selectedTopics = [...topics];
        }

        // 切換主題選擇
        function toggleTopic(topic) {
            const checkbox = document.getElementById(`topic-${topic}`);
            const topicItem = checkbox.parentElement;
            
            if (checkbox.checked) {
                topicItem.classList.add('selected');
                if (!selectedTopics.includes(topic)) {
                    selectedTopics.push(topic);
                }
            } else {
                topicItem.classList.remove('selected');
                selectedTopics = selectedTopics.filter(t => t !== topic);
            }
        }

        // 切換難度選擇
        document.addEventListener('DOMContentLoaded', function() {
            const difficultyOptions = document.querySelectorAll('.difficulty-option');
            difficultyOptions.forEach(option => {
                const checkbox = option.querySelector('input[type="checkbox"]');
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        option.classList.add('selected');
                    } else {
                        option.classList.remove('selected');
                    }
                });
            });
        });

        // 選擇題目數量
        function selectQuestionCount(count) {
            document.querySelectorAll('.count-option').forEach(option => {
                option.classList.remove('selected');
            });
            event.target.classList.add('selected');
            questionCount = count;
        }

        // 開始客製化測驗
        function startCustomExam() {
            if (selectedTopics.length === 0) {
                alert('請至少選擇一個考試範圍！');
                return;
            }
            
            selectedDifficulties = [];
            if (document.getElementById('diff-easy').checked) selectedDifficulties.push('easy');
            if (document.getElementById('diff-medium').checked) selectedDifficulties.push('medium');
            if (document.getElementById('diff-hard').checked) selectedDifficulties.push('hard');
            
            if (selectedDifficulties.length === 0) {
                alert('請至少選擇一個難度等級！');
                return;
            }
            
            let filteredQuestions = questionBank.filter(q => 
                selectedTopics.includes(q.topic) && 
                selectedDifficulties.includes(q.difficulty)
            );
            
            if (filteredQuestions.length < questionCount) {
                alert(`符合條件的題目只有 ${filteredQuestions.length} 題，少於所選的 ${questionCount} 題！`);
                return;
            }
            
            currentQuestions = shuffleArray(filteredQuestions).slice(0, questionCount);
            currentQuestionIndex = 0;
            userAnswers = new Array(currentQuestions.length).fill(null);
            
            timeLeft = questionCount * 2 * 60; // 每題2分鐘
            examStartTime = new Date();
            
            document.getElementById('setupScreen').style.display = 'none';
            document.getElementById('statsBar').style.display = 'grid';
            document.getElementById('progressBar').style.display = 'block';
            document.getElementById('questionContainer').style.display = 'block';
            
            document.getElementById('totalQ').textContent = currentQuestions.length;
            
            startTimer();
            loadQuestion();
        }

        // 洗牌演算法
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // 開始計時器
        function startTimer() {
            timer = setInterval(() => {
                timeLeft--;
                updateTimerDisplay();
                
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    endExam();
                }
            }, 1000);
        }

        // 更新計時器顯示
        function updateTimerDisplay() {
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            document.getElementById('timeLeft').textContent = 
                `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        // 載入題目
        function loadQuestion() {
            const question = currentQuestions[currentQuestionIndex];
            
            document.getElementById('questionNum').textContent = currentQuestionIndex + 1;
            document.getElementById('currentQ').textContent = currentQuestionIndex + 1;
            document.getElementById('topicTag').textContent = question.topic;
            document.getElementById('difficultyTag').textContent = 
                question.difficulty === 'easy' ? '簡單' : 
                question.difficulty === 'medium' ? '中等' : '困難';
            document.getElementById('difficultyTag').className = `difficulty ${question.difficulty}`;
            
            document.getElementById('questionText').textContent = question.question;
            
            const codeBlock = document.getElementById('codeBlock');
            if (question.code) {
                codeBlock.textContent = question.code;
                codeBlock.style.display = 'block';
            } else {
                codeBlock.style.display = 'none';
            }
            
            const optionsContainer = document.getElementById('optionsContainer');
            optionsContainer.innerHTML = '';
            
            question.options.forEach((option, index) => {
                const optionElement = document.createElement('div');
                optionElement.className = 'option';
                optionElement.onclick = () => selectOption(index);
                
                const letter = String.fromCharCode(65 + index);
                optionElement.innerHTML = `
                    <div class="option-letter">${letter}</div>
                    <div class="option-text">${option}</div>
                `;
                
                optionsContainer.appendChild(optionElement);
            });
            
            if (userAnswers[currentQuestionIndex] !== null) {
                selectOption(userAnswers[currentQuestionIndex], false);
            }
            
            document.getElementById('prevBtn').disabled = currentQuestionIndex === 0;
            document.getElementById('submitBtn').style.display = 'inline-block';
            document.getElementById('nextBtn').style.display = 'none';
            document.getElementById('feedback').style.display = 'none';
            
            const progress = ((currentQuestionIndex + 1) / currentQuestions.length) * 100;
            document.getElementById('progressFill').style.width = `${progress}%`;
        }

        // 選擇選項
        function selectOption(index, updateAnswer = true) {
            document.querySelectorAll('.option').forEach(option => {
                option.classList.remove('selected');
            });
            
            const options = document.querySelectorAll('.option');
            options[index].classList.add('selected');
            
            if (updateAnswer) {
                userAnswers[currentQuestionIndex] = index;
            }
        }

        // 提交答案
        function submitAnswer() {
            if (userAnswers[currentQuestionIndex] === null) {
                alert('請選擇一個答案！');
                return;
            }
            
            const question = currentQuestions[currentQuestionIndex];
            const userAnswer = userAnswers[currentQuestionIndex];
            const isCorrect = userAnswer === question.correct;
            
            const options = document.querySelectorAll('.option');
            options.forEach((option, index) => {
                if (index === question.correct) {
                    option.classList.add('correct');
                } else if (index === userAnswer && !isCorrect) {
                    option.classList.add('incorrect');
                }
            });
            
            const feedback = document.getElementById('feedback');
            feedback.className = `feedback ${isCorrect ? 'correct' : 'incorrect'}`;
            feedback.style.display = 'block';
            
            const explanationContent = document.getElementById('explanationContent');
            explanationContent.innerHTML = `
                <p><strong>${isCorrect ? '✅ 答對了！' : '❌ 答錯了！'}</strong></p>
                <p><strong>正確答案：</strong>${String.fromCharCode(65 + question.correct)} - ${question.options[question.correct]}</p>
                <p><strong>解析：</strong>${question.explanation}</p>
                ${question.reference ? `<p><strong>📚 參考資料：</strong>${question.reference}</p>` : ''}
                ${question.codeExample ? `<div class="code-example"><strong>💻 程式碼範例：</strong><pre><code>${question.codeExample}</code></pre></div>` : ''}
            `;
            
            updateScore();
            
            document.getElementById('submitBtn').style.display = 'none';
            document.getElementById('nextBtn').style.display = 'inline-block';
        }

        // 更新分數
        function updateScore() {
            const correctAnswers = userAnswers.filter((answer, index) => 
                answer !== null && answer === currentQuestions[index].correct
            ).length;
            
            const score = Math.round((correctAnswers / currentQuestions.length) * 100);
            
            document.getElementById('currentScore').textContent = score;
            document.getElementById('correctCount').textContent = correctAnswers;
        }

        // 下一題
        function nextQuestion() {
            if (currentQuestionIndex < currentQuestions.length - 1) {
                currentQuestionIndex++;
                loadQuestion();
            } else {
                endExam();
            }
        }

        // 上一題
        function previousQuestion() {
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                loadQuestion();
            }
        }

        // 結束考試
        function endExam() {
            clearInterval(timer);
            
            const correctAnswers = userAnswers.filter((answer, index) => 
                answer !== null && answer === currentQuestions[index].correct
            ).length;
            
            const totalQuestions = currentQuestions.length;
            const score = Math.round((correctAnswers / totalQuestions) * 100);
            
            document.getElementById('statsBar').style.display = 'none';
            document.getElementById('progressBar').style.display = 'none';
            document.getElementById('questionContainer').style.display = 'none';
            
            document.getElementById('finalScore').style.display = 'block';
            document.getElementById('scoreCircle').textContent = `${score}分`;
            
            let resultTitle, scoreMessage, circleColor;
            if (score >= 90) {
                resultTitle = '🏆 優秀！';
                scoreMessage = '恭喜！您的表現非常出色！';
                circleColor = '#10b981';
            } else if (score >= 80) {
                resultTitle = '🎉 良好！';
                scoreMessage = '做得很好！繼續保持！';
                circleColor = '#3b82f6';
            } else if (score >= 60) {
                resultTitle = '👍 及格！';
                scoreMessage = '通過測驗！還有進步空間！';
                circleColor = '#f59e0b';
            } else {
                resultTitle = '💪 加油！';
                scoreMessage = '需要更多練習，不要放棄！';
                circleColor = '#ef4444';
            }
            
            document.getElementById('resultTitle').textContent = resultTitle;
            document.getElementById('scoreMessage').textContent = scoreMessage;
            document.getElementById('scoreCircle').style.background = circleColor;
            
            showTopicStats();
        }

        // 顯示主題統計
        function showTopicStats() {
            const topicStats = {};
            
            currentQuestions.forEach((question, index) => {
                const topic = question.topic;
                if (!topicStats[topic]) {
                    topicStats[topic] = { correct: 0, total: 0 };
                }
                topicStats[topic].total++;
                if (userAnswers[index] === question.correct) {
                    topicStats[topic].correct++;
                }
            });
            
            const topicStatsContainer = document.getElementById('topicStats');
            topicStatsContainer.innerHTML = '';
            
            Object.entries(topicStats).forEach(([topic, stats]) => {
                const percentage = Math.round((stats.correct / stats.total) * 100);
                const statElement = document.createElement('div');
                statElement.className = 'topic-stat';
                statElement.innerHTML = `
                    <h4>${topic}</h4>
                    <p>答對：${stats.correct} / ${stats.total} 題</p>
                    <p>正確率：${percentage}%</p>
                `;
                topicStatsContainer.appendChild(statElement);
            });
        }

        // 返回設定畫面
        function backToSetup() {
            currentQuestions = [];
            currentQuestionIndex = 0;
            userAnswers = [];
            timeLeft = 3600;
            
            document.getElementById('finalScore').style.display = 'none';
            document.getElementById('setupScreen').style.display = 'block';
        }

        // 頁面載入完成後自動聚焦到帳號輸入框
        window.addEventListener('load', () => {
            document.getElementById('username').focus();
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'96ef54e237df4a21',t:'MTc1NTE2Mjc1Ny4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
